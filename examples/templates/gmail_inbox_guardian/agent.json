{
  "agent": {
    "id": "gmail_inbox_guardian",
    "name": "Gmail Inbox Guardian",
    "version": "1.0.0",
    "description": "Event-driven Gmail inbox agent. Define free-text rules for email triage (star, spam, trash, mark read/unread, label, etc.) and the agent automatically applies them to incoming emails when triggered by external events."
  },
  "graph": {
    "id": "gmail-inbox-guardian-graph",
    "goal_id": "gmail-inbox-guardian",
    "version": "1.0.0",
    "entry_node": "intake",
    "entry_points": {
      "start": "intake"
    },
    "async_entry_points": [
      {
        "id": "email-event",
        "name": "Email Event Handler",
        "entry_node": "fetch-emails",
        "trigger_type": "event",
        "trigger_config": {
          "event_types": ["webhook_received"]
        },
        "isolation_level": "shared",
        "max_concurrent": 10
      }
    ],
    "pause_nodes": [],
    "terminal_nodes": [],
    "conversation_mode": "continuous",
    "identity_prompt": "You are an inbox management assistant. You help users manage their Gmail inbox by applying free-text rules to emails \u2014 trash, mark as spam, mark important, mark read/unread, star, and more.",
    "nodes": [
      {
        "id": "intake",
        "name": "Rule Setup",
        "description": "User defines or updates email triage rules in plain language. Rules persist in shared memory for event-driven processing.",
        "node_type": "event_loop",
        "input_keys": [],
        "output_keys": ["rules", "max_emails"],
        "nullable_output_keys": [],
        "system_prompt": "You are an inbox guardian assistant. The user will define rules for automatically triaging their Gmail inbox.\n\n**STEP 1 \u2014 Respond to the user (text only, NO tool calls):**\n\nRead what the user wants. They will describe rules in plain language like:\n- \"Star emails from my boss\"\n- \"Spam anything from marketing newsletters\"\n- \"Mark as read all notifications from GitHub\"\n- \"Trash emails with 'unsubscribe' in the subject\"\n\nPresent a clear summary of the rules you understood, mapped to Gmail actions:\n\nAvailable Gmail actions:\n- **Trash** emails\n- **Mark as spam**\n- **Mark as important** / unmark important\n- **Mark as read** / mark as unread\n- **Star** / unstar emails\n- **Archive** (remove from inbox)\n- **Add/remove Gmail labels** (INBOX, UNREAD, IMPORTANT, STARRED, SPAM, etc.)\n\nAlso confirm the batch size (max_emails). Default to 50 if not specified.\n\nAsk the user to confirm: \"Does this look right? I'll start applying these rules to incoming emails once you confirm.\"\n\nIf this is a RETURN VISIT (rules already exist in context), ask: \"Your current rules are active. Would you like to modify them, or are they working well?\"\n\n**STEP 2 \u2014 After the user confirms, call set_output:**\n\n- set_output(\"rules\", <the confirmed rules as a clear text description>)\n- set_output(\"max_emails\", <the confirmed max_emails as a string number, e.g. \"50\">)",
        "tools": [],
        "model": null,
        "client_facing": true,
        "max_node_visits": 0,
        "max_retries": 3,
        "max_validation_retries": 2
      },
      {
        "id": "fetch-emails",
        "name": "Fetch Emails",
        "description": "Fetches new emails from Gmail inbox up to the configured batch limit. Writes email data to emails.jsonl for downstream processing.",
        "node_type": "event_loop",
        "input_keys": ["rules", "max_emails"],
        "output_keys": ["emails"],
        "nullable_output_keys": [],
        "system_prompt": "You are a data pipeline step. Your job is to fetch new emails from Gmail and write them to emails.jsonl.\n\n**STEPS:**\n1. Read \"max_emails\" from input context. Default to 50 if not set.\n2. Call gmail_list_messages(query=\"label:INBOX is:unread\", max_results=<max_emails>) to get message IDs.\n3. If no messages found, call set_output(\"emails\", \"no_new_emails\") and stop.\n4. Call gmail_batch_get_messages(message_ids=<list of IDs>, format=\"metadata\") to get full metadata. Process in batches of 50 if needed.\n5. For each message, call append_data(filename=\"emails.jsonl\", data=<JSON: {id, subject, from, to, date, snippet, labels}>).\n6. Call set_output(\"emails\", \"emails.jsonl\").\n\nDo NOT add commentary or explanation. Execute the steps and call set_output when done.",
        "tools": ["gmail_list_messages", "gmail_batch_get_messages", "append_data"],
        "model": null,
        "client_facing": false,
        "max_node_visits": 0,
        "max_retries": 3,
        "max_validation_retries": 2
      },
      {
        "id": "classify-and-act",
        "name": "Classify and Act",
        "description": "Applies the user's rules to each email and executes the appropriate Gmail actions (star, spam, trash, mark read/unread, label, etc.).",
        "node_type": "event_loop",
        "input_keys": ["rules", "emails"],
        "output_keys": ["actions_taken"],
        "nullable_output_keys": [],
        "system_prompt": "You are an inbox guardian. Apply the user's rules to their emails and execute Gmail actions.\n\n**YOUR TOOLS:**\n- load_data(filename, offset_bytes, limit_bytes) \u2014 Read emails from a local file using byte-based pagination.\n- append_data(filename, data) \u2014 Append a line to a file. Use this to record actions taken.\n- gmail_batch_modify_messages(message_ids, add_labels, remove_labels) \u2014 Modify Gmail labels in batch. ALWAYS prefer this.\n- gmail_modify_message(message_id, add_labels, remove_labels) \u2014 Modify a single message's labels.\n- gmail_trash_message(message_id) \u2014 Move a message to trash. No batch version; call per email.\n- set_output(key, value) \u2014 Set an output value. Call ONLY after all actions are executed.\n\n**CONTEXT:**\n- \"rules\" = the user's rules to apply (e.g. \"star emails from my boss, spam newsletters\")\n- \"emails\" = a filename (e.g. \"emails.jsonl\") containing fetched emails as JSONL. Each line has: id, subject, from, to, date, snippet, labels.\n- If \"emails\" equals \"no_new_emails\", call set_output(\"actions_taken\", \"no_new_emails\") and stop.\n\n**STEP 1 \u2014 LOAD EMAILS (your first tool call MUST be load_data):**\nCall load_data(filename=<the \"emails\" value from context>, limit_bytes=10000) to read the email data.\n- Parse the content as JSONL: split by \\n, then JSON.parse each line to get email objects.\n- If has_more=true, load more pages with load_data(filename=..., offset_bytes=<next_offset_bytes>) until all emails are loaded.\n\n**STEP 2 \u2014 CLASSIFY EACH EMAIL:**\nFor each email, determine which rule(s) apply based on sender, subject, snippet, and labels.\nGroup emails by the action to take.\n\n**STEP 3 \u2014 EXECUTE ACTIONS:**\n- **Blanket rule** (same action for ALL emails): Collect all message IDs, execute ONE gmail_batch_modify_messages call.\n- **Mixed rules** (different actions): Group by action, execute batch operations per group.\n- For trash: use gmail_trash_message(message_id) per email (no batch version).\n- Record each action: append_data(filename=\"actions.jsonl\", data=<JSON of {email_id, subject, from, action}>)\n\n**STEP 4 \u2014 FINISH:**\nAfter ALL actions are executed, call set_output(\"actions_taken\", \"actions.jsonl\").\n\n**GMAIL LABEL REFERENCE:**\n- MARK AS UNREAD \u2014 add_labels=[\"UNREAD\"]\n- MARK AS READ \u2014 remove_labels=[\"UNREAD\"]\n- MARK IMPORTANT \u2014 add_labels=[\"IMPORTANT\"]\n- REMOVE IMPORTANT \u2014 remove_labels=[\"IMPORTANT\"]\n- STAR \u2014 add_labels=[\"STARRED\"]\n- UNSTAR \u2014 remove_labels=[\"STARRED\"]\n- ARCHIVE \u2014 remove_labels=[\"INBOX\"]\n- MARK AS SPAM \u2014 add_labels=[\"SPAM\"], remove_labels=[\"INBOX\"]\n- TRASH \u2014 use gmail_trash_message(message_id) per email\n\n**CRITICAL RULES:**\n- Your FIRST tool call MUST be load_data. Do NOT skip this.\n- You MUST call Gmail tools to execute real actions. Do NOT just report what should be done.\n- Do NOT call set_output until all Gmail actions are executed.\n- Pass ONLY the filename \"actions.jsonl\" to set_output, NOT raw data.",
        "tools": ["gmail_trash_message", "gmail_modify_message", "gmail_batch_modify_messages", "load_data", "append_data"],
        "model": null,
        "client_facing": false,
        "max_node_visits": 0,
        "max_retries": 3,
        "max_validation_retries": 2
      },
      {
        "id": "report",
        "name": "Report",
        "description": "Generates a summary report of all actions taken on emails. Non-blocking \u2014 saves the report and completes so the agent resumes listening.",
        "node_type": "event_loop",
        "input_keys": ["actions_taken"],
        "output_keys": ["summary_report"],
        "nullable_output_keys": [],
        "system_prompt": "You are an inbox guardian reporter. Generate a summary of the actions taken on emails.\n\n**STEP 1 \u2014 Load actions:**\n- If \"actions_taken\" equals \"no_new_emails\", call set_output(\"summary_report\", \"No new emails to process.\") and stop.\n- Otherwise, call load_data(filename=<the actions_taken value>, limit_bytes=10000) to read action records.\n- The file is JSONL format: each line is {email_id, subject, from, action}.\n- If has_more=true, load more pages until all records are read.\n\n**STEP 2 \u2014 Generate and save the report:**\nCreate a clean summary:\n1. **Overview** \u2014 Total emails processed, breakdown by action type.\n2. **By Action** \u2014 Group emails by action taken. For each group, list email subjects and senders.\n\nSave the report:\n  save_data(filename=\"report.txt\", data=<the formatted report text>)\n\n**STEP 3 \u2014 Call set_output:**\n  set_output(\"summary_report\", <the formatted report text>)\n\nDo NOT block for user input. Generate the report and finish immediately.",
        "tools": ["load_data", "save_data"],
        "model": null,
        "client_facing": false,
        "max_node_visits": 0,
        "max_retries": 3,
        "max_validation_retries": 2
      }
    ],
    "edges": [
      {
        "id": "intake-to-intake",
        "source": "intake",
        "target": "intake",
        "condition": "on_success",
        "priority": 1
      },
      {
        "id": "fetch-emails-to-classify",
        "source": "fetch-emails",
        "target": "classify-and-act",
        "condition": "on_success",
        "priority": 1
      },
      {
        "id": "classify-to-report",
        "source": "classify-and-act",
        "target": "report",
        "condition": "on_success",
        "priority": 1
      }
    ],
    "max_steps": 100,
    "max_retries_per_node": 3,
    "description": "Event-driven Gmail inbox agent. Define free-text rules for email triage and the agent automatically applies them to incoming emails when triggered by external events."
  },
  "goal": {
    "id": "gmail-inbox-guardian",
    "name": "Gmail Inbox Guardian",
    "description": "An event-driven Gmail inbox agent. The user defines free-text rules for email triage. When triggered by external events, the agent fetches new emails, classifies each one against the user's rules, executes the appropriate Gmail actions, and reports what was done.",
    "status": "draft",
    "success_criteria": [
      {
        "id": "rule-understanding",
        "description": "Correctly interprets user free-text rules and maps them to Gmail actions",
        "metric": "rule_accuracy",
        "target": ">=95%",
        "weight": 0.25,
        "met": false
      },
      {
        "id": "action-execution",
        "description": "Gmail actions are applied to the correct emails based on rule matching",
        "metric": "action_correctness",
        "target": ">=95%",
        "weight": 0.30,
        "met": false
      },
      {
        "id": "batch-completeness",
        "description": "All fetched emails are processed; none silently skipped",
        "metric": "emails_processed_ratio",
        "target": "100%",
        "weight": 0.25,
        "met": false
      },
      {
        "id": "summary-report",
        "description": "Produces a clear report of actions taken grouped by action type with email subjects and senders",
        "metric": "report_completeness",
        "target": "100%",
        "weight": 0.20,
        "met": false
      }
    ],
    "constraints": [
      {
        "id": "non-destructive-default",
        "description": "Archiving removes from inbox but preserves email; only explicit trash/spam rules move emails to trash/spam",
        "constraint_type": "hard",
        "category": "safety"
      },
      {
        "id": "respect-batch-limit",
        "description": "Must not process more emails than the configured max_emails parameter",
        "constraint_type": "hard",
        "category": "operational"
      },
      {
        "id": "shared-rule-state",
        "description": "Rules must persist in shared memory so event-driven executions can access them without re-asking the user",
        "constraint_type": "hard",
        "category": "architectural"
      }
    ]
  },
  "required_tools": [
    "gmail_list_messages",
    "gmail_batch_get_messages",
    "gmail_trash_message",
    "gmail_modify_message",
    "gmail_batch_modify_messages",
    "load_data",
    "save_data",
    "append_data"
  ],
  "metadata": {
    "node_count": 4,
    "edge_count": 4
  }
}
